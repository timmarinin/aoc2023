i â† â€¢FLines "input_3.txt"

rowlen â† â‰  i
celllen â† âŒˆÂ´ â‰ Â¨ i

m â† rowlenâ€¿celllen â¥Š âˆ¾ i
# General idea: find positions of all symbols (non-digits, non-dot),
# Then check neighbours for digits, merge numbers, sum.
IsSymbol â† âŠ‘âˆ˜>âˆ˜(Â¬ âˆŠ âŸœ ".0123456789")
symbols â† IsSymbolÂ¨ m
N â† Â« â‹„ S â† Â» â‹„ E â† Â»Ë˜ â‹„ W â† Â«Ë˜ â‹„ SE â† Â»Â»Ë˜ â‹„ NE â† Â«Â»Ë˜ â‹„ NW â† Â«Â«Ë˜ â‹„ SW â† Â»Â«Ë˜
Neighbourhood â† { âˆ¨Â´ (âŸ¨n, s, e, w, se, ne, nw, swâŸ© {ğ•ğ•©}Â¨ <ğ•©) }
neighbours â† Neighbourhood symbols

IsDigit â† â‰¥âŸœ'0' âˆ§ â‰¤âŸœ'9'
digits â† IsDigitÂ¨ m
digitsOnly â† { (IsDigit ğ•©) âŠ‘ âŸ¨'.', ğ•©âŸ© }Â¨ m

pointers â† digitsâˆ§neighbours

GroupsOf1 â† { ğ•¨(âŠ¢âˆ§âˆ§(âŠ¢âˆŠ/)Â·+`Â»âŠ¸<âˆ˜âŠ¢)ğ•© } # from bqncrate: Groups of ones in b1 pointed to by at least one 1 in a1
SplitByDot â† { '.'((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢) ğ•© } # from bqncrate
# StartLen1 â† { -Ëœ`Ë˜âˆ˜â€¿2â¥Š/0(âˆ¾â‰ âˆ¾Ëœ) ğ•© }
# LengthsOf1 â† { -ËœËË˜âˆ˜â€¿2â¥Š/0(âˆ¾â‰ âˆ¾Ëœ) ğ•© }
neededDigits â† pointers GroupsOf1Ë˜ digits
neededDigitsMasked â† neededDigits { ğ•¨ âŠ‘ âŸ¨'.', ğ•©âŸ© }Â¨ digitsOnly

rowresult â† (+Â´ (â€¢ParseFloatÂ¨ SplitByDot))Ë˜ neededDigitsMasked
â€¢Show "Part A: "â€¿(+Â´ rowresult)

# PART B:
## General idea: check gear one-by-one
gearCandidates â† '*'âŠ¸=Â¨ m

CheckGear â† {
    neighbours â† Neighbourhood ğ•©
    pointers â† digitsâˆ§neighbours
    neededDigits â† pointers GroupsOf1Ë˜ digits
    neededDigitsMasked â† neededDigits { ğ•¨ âŠ‘ âŸ¨'.', ğ•©âŸ© }Â¨ digitsOnly
    partNumbers â† (< SplitByDot)Ë˜ neededDigitsMasked
    partNumbers â†© âˆ¾ ((â‰ Â¨ partNumbers) > 0) / partNumbers
    ((â‰ partNumbers)=2) âŠ‘ âŸ¨âŸ¨0âŸ©, (Ã—Â´ â€¢ParseFloatÂ¨ partNumbers)âŸ©
}

flatGears â† â¥Š gearCandidates
gearIndices â† / flatGears

ratios â† âˆ¾Â´ {
    (ğ•© CheckGear (rowlenâ€¿celllen â¥Š (ğ•©âŠ¸= â†•â‰ flatGears)))
}Â¨ gearIndices

â€¢Show "Part B: "â€¿(+Â´ ratios) 